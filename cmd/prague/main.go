package main

import (
	"fmt"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

var (
	address = "http://127.0.0.1:8545"
)

func main() {
	test2537()
}

func testTouchContracts() {
	// touch beacon root addr
	addresses := []common.Address{
		common.HexToAddress("0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02"), // beacon roots
		common.HexToAddress("0x00A3ca265EBcb825B45F985A16CEFB49958cE017"), // withdrawal requests
		common.HexToAddress("0xfffffffffffffffffffffffffffffffffffffffe"), // system address
		common.HexToAddress("0x25a219378dad9b3503c8268c9ca836a52427a4fb"), // history storage address
		common.HexToAddress("0x00000000219ab540356cbb839cbe05303d7705fa"), // mainnet deposit contract
		common.HexToAddress("0x4242424242424242424242424242424242424242"), // testnet deposit address
	}

	for _, addr := range addresses {
		exec(addr, []byte{}, false)                       // no data
		exec(addr, []byte{1}, false)                      // 1 byte of data
		exec(addr, crypto.Keccak256([]byte{1})[:], false) // 32 bytes of data
		exec(addr, make([]byte, 2048), false)             // 2048 bytes of data
	}

}

func test2537() {
	testBLSAdd()
}

func testBLSAdd() {
	addr, err := deployPrecompileCaller("0b")
	if err != nil {
		panic(err)
	}
	// Small input
	exec(addr, []byte{0x5f}, true)
	// Big input
	var input []byte
	for i := 0; i < 1000; i++ {
		input = append(input, 0xff)
	}
	exec(addr, input, true)
	// Correct input
	input = common.FromHex("000000000000000000000000000000000572cbea904d67468808c8eb50a9450c9721db309128012543902d0ac358a62ae28f75bb8f1c7c42c39a8c5529bf0f4e00000000000000000000000000000000166a9d8cabc673a322fda673779d8e3822ba3ecb8670e461f73bb9021d5fd76a4c56d9d4cd16bd1bba86881979749d280000000000000000000000000000000009ece308f9d1f0131765212deca99697b112d61f9be9a5f1f3780a51335b3ff981747a0b2ca2179b96d2c0c9024e522400000000000000000000000000000000032b80d3a6f5b09f8a84623389c5f80ca69a0cddabc3097f9d9c27310fd43be6e745256c634af45ca3473b0590ae30d1")
	exec(addr, input, true)
}

/*
pragma solidity >=0.7.0 <0.9.0;

	contract BlobCaller {
	    bool _ok;
	    bytes out;

	    fallback (bytes calldata _input) external returns (bytes memory _output) {
	        address precompile = address(0x0A);
	        (bool ok, bytes memory output) = precompile.call{gas: 500000}(_input);
	        _output = output;
	        // Store return values to trigger sstore
	        _ok = ok;
	        out = output;
	    }
	}
*/
func deployPrecompileCaller(precompile string) (common.Address, error) {
	bytecode1 := "6080604052348015600e575f80fd5b506104568061001c5f395ff3fe608060405234801561000f575f80fd5b505f3660605f60"
	bytecode2 := "90505f808273ffffffffffffffffffffffffffffffffffffffff1661c35087876040516100459291906100fe565b5f604051808303815f8787f1925050503d805f811461007f576040519150601f19603f3d011682016040523d82523d5f602084013e610084565b606091505b5091509150809350815f806101000a81548160ff02191690831515021790555080600190816100b39190610350565b50505050915050805190602001f35b5f81905092915050565b828183375f83830152505050565b5f6100e583856100c2565b93506100f28385846100cc565b82840190509392505050565b5f61010a8284866100da565b91508190509392505050565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061019157607f821691505b6020821081036101a4576101a361014d565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026102067fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826101cb565b61021086836101cb565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f61025461024f61024a84610228565b610231565b610228565b9050919050565b5f819050919050565b61026d8361023a565b6102816102798261025b565b8484546101d7565b825550505050565b5f90565b610295610289565b6102a0818484610264565b505050565b5b818110156102c3576102b85f8261028d565b6001810190506102a6565b5050565b601f821115610308576102d9816101aa565b6102e2846101bc565b810160208510156102f1578190505b6103056102fd856101bc565b8301826102a5565b50505b505050565b5f82821c905092915050565b5f6103285f198460080261030d565b1980831691505092915050565b5f6103408383610319565b9150826002028217905092915050565b61035982610116565b67ffffffffffffffff81111561037257610371610120565b5b61037c825461017a565b6103878282856102c7565b5f60209050601f8311600181146103b8575f84156103a6578287015190505b6103b08582610335565b865550610417565b601f1984166103c6866101aa565b5f5b828110156103ed578489015182556001820191506020850194506020810190506103c8565b8683101561040a5784890151610406601f891682610319565b8355505b6001600288020188555050505b50505050505056fea2646970667358221220bc28435cfa3208db8cae33e216a1ff54a6e5dce073695cad36274cc363055c5564736f6c63430008190033"
	// The byte in between bytecode1 and bytecode2 denotes the precompile which we want to call
	return deploy(fmt.Sprintf("%v%v%v", bytecode1, precompile, bytecode2))
}
